#!/bin/python

from __future__ import division
import numpy as np
from collections import namedtuple
import matplotlib.pyplot as pl

BORDER = 12
Center = namedtuple("Center", ("center", "elements"))


def find_closest_element(centroid, new_center):
    """
    Returning the closest element to the new center of the group
    :param centroid:
    :param new_center:
    :return:
    """
    curr_center = (centroid.center, distance(centroid.center, new_center))

    for vector in centroid.elements:
        dist = distance(vector, new_center)
        if dist < curr_center[1]:
            curr_center = (vector, dist)

    return curr_center[0]


def randomize_centroids(data, k):

    centroids = []
    index = 0

    for vector in data:
        if index == k:
            break

        centroids.append(Center(vector, []))
        index += 1

    return centroids


def distance(element, c):
    """
    Calculate the distance between two vectors
    :param element: array
    :param c: array
    :return: float
    """
    return np.linalg.norm(element - c)


def find_centroid(element, centroids):
    """
    Match element with a center
    :param element: vector
    :param centroids: list of vectors
    :return: None
    """
    closest = None

    for c in centroids:
        if closest is None:
            closest = (c, distance(element, c.center))
            continue

        dist = distance(element, c.center)
        if dist < closest[1]:
            closest = (c, dist)

    closest[0].elements.append(element)


def get_center(elements):
    """
    Find the new center of the group
    :param elements: list of vectors
    :return: vector
    """
    return sum(elements) / len(elements)


def centralize(centroids):
    """
    Find the new centers of the clusters
    :param centroids: list of Centers
    :return: boolean
    """
    changed = False

    for center in centroids:
        new_center = get_center(center.elements)
        new_center = find_closest_element(center, new_center)
        if new_center is not center.center:
            changed = True
            center.center.clear()
            center.center.extend(new_center)

    return changed


def kmeans(data, k):
    """
    Divide the data into k clusters, using the k means algorithm
    :param data: list of arrays
    :param k: int
    :return: list of Centers
    """

    centroids = randomize_centroids(data, k)
    changed = True

    while changed:
        # Prepare list for next iteration
        for c in centroids:
            c.elements.clear()

        # Find the centroid for each data element
        for element in data:
            find_centroid(np.array(element), centroids)

        # find the new centroids
        changed = centralize(centroids)

    return centroids


def plot_data(data):
    x_group = []
    y_group = []

    extra_space = 5

    for x, y in data:
        x_group.append(x)
        y_group.append(y)

    x_border = max(x_group)
    y_border = max(y_group)

    pl.plot(x_group, y_group, 'o')
    pl.axis([0, BORDER, 0, BORDER])
    pl.show()


def test():
    n = 5
    dim = 2
    k = 1

    #data = np.random.rand(n, dim) * BORDER

    a1 = np.array([1.0, 1.0])
    a2 = np.array([2.0, 2.0])
    a3 = np.array([3.0, 3.0])
    #a4 = np.array([0.5, 1.0])
    #a5 = np.array([10.0, 10.0])
    #a6 = np.array([9.0, 10.0])

    data = np.array([a1, a2, a3])

    kmean = kmeans(data, k)

    for c, e in kmean:
        print("the group: {center} : {elements}".format(center=c, elements=e))

    plot_data(data)
    kmean_x = [k.center[0] for k in kmean]
    kmean_y = [k.center[1] for k in kmean]

    pl.plot(kmean_x, kmean_y,'ro')



test()
